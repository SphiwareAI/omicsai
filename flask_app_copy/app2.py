from flask import Flask, render_template, request, redirect, url_for, send_from_directory, flash
from werkzeug.utils import secure_filename
import os
import subprocess
import pandas as pd
import joblib

app = Flask(__name__)

# Configuration
app.config['UPLOAD_FOLDER'] = 'uploads'
app.config['OUTPUT_FASTQC'] = 'outputs/output_fastqc'
app.config['OUTPUT_VELVET'] = 'outputs/output_velvet'
app.config['ALLOWED_EXTENSIONS'] = {'fastq', 'gz'}

# Ensure the upload and output directories exist
for key in app.config:
    if key.startswith('OUTPUT_') and not os.path.exists(app.config[key]):
        os.makedirs(app.config[key])

# Function to check if a file has an allowed extension
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/check_quality', methods=['GET', 'POST'])
def check_quality():
    if request.method == 'POST':
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)

        filename = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(file.filename))
        file.save(filename)

        cmd = ['fastqc', filename, '-o', app.config['OUTPUT_FASTQC']]
        subprocess.run(cmd)

        # Extract the name of the HTML report generated by FastQC
        html_report = secure_filename(file.filename.replace('.fastq.gz', '_fastqc.html'))
        zip_report = secure_filename(file.filename.replace('.fastq.gz', '_fastqc.zip'))

        return render_template('quality_check.html', uploaded=True, html_report=html_report, zip_report=zip_report)

    return render_template('quality_check.html', uploaded=False)

@app.route('/genome_assembly', methods=['GET', 'POST'])
def genome_assembly():
    feedback = None
    contigs = None
    stats = None

    if request.method == 'POST':
        files = request.files.getlist('file')

        if len(files) != 2:
            feedback = "Please upload exactly two files for paired-end reads."
            return render_template('genome_assembly.html', feedback=feedback)

        file_paths = []
        for file in files:
            if file and allowed_file(file.filename):
                filename = secure_filename(file.filename)
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                file.save(filepath)
                file_paths.append(filepath)

        hash_length = 31
        cmd_velveth = f"velveth {OUTPUT_VELVET} {hash_length} -shortPaired -separate -fastq {' '.join(file_paths)}"
        cmd_velvetg = f"velvetg {OUTPUT_VELVET}"

        os.system(cmd_velveth)
        os.system(cmd_velvetg)

        # Check if contigs.fa and stats.txt exist
        if os.path.exists(os.path.join(OUTPUT_VELVET, 'contigs.fa')):
            contigs = 'contigs.fa'
        if os.path.exists(os.path.join(OUTPUT_VELVET, 'stats.txt')):
            stats = 'stats.txt'

        feedback = "Upload and assembly successful!"

    return render_template('genome_assembly.html', feedback=feedback, contigs=contigs, stats=stats)

@app.route('/outputs/<path:subdir>/<filename>')
def output_files(subdir, filename):
    return send_from_directory(os.path.join('outputs', subdir), filename, as_attachment=False)

@app.route('/gene_prediction', methods=['POST', 'GET'])
def gene_prediction():
    feedback = None
    protein_file = None

    if request.args.get('from_assembly') == 'true':
        contigs_path = os.path.join(OUTPUT_VELVET, 'contigs.fa')
        if os.path.exists(contigs_path):
            output_path = os.path.join(OUTPUT_PRODIGAL, 'out.faa')
            cmd = ['prodigal', '-i', contigs_path, '-p', 'normal', '-q', '-a', output_path]
            subprocess.run(cmd)
            feedback = "Gene prediction was successful!"
            protein_file = 'out.faa'
        else:
            feedback = "contigs.fa file not found. Please run the genomic assembly first."

    elif 'file' in request.files:
        uploaded_file = request.files['file']
        
        if uploaded_file.filename == '':
            feedback = "No file selected."
        elif uploaded_file and allowed_file(uploaded_file.filename):
            filename = secure_filename(uploaded_file.filename)
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            uploaded_file.save(filepath)
            output_path = os.path.join(OUTPUT_PRODIGAL, 'out.faa')
            cmd = ['prodigal', '-i', filepath, '-p', 'normal', '-q', '-a', output_path]
            subprocess.run(cmd)
            feedback = "Gene prediction was successful!"
            protein_file = 'out.faa'
        else:
            feedback = "Invalid file type. Please upload a .fa file."

    return render_template('gene_prediction.html', feedback=feedback, protein_file=protein_file)

#@app.route('/index', methods=['POST', 'GET'])
#def display_index():
#    user_id = request.cookies
#    session_id = request.cookies['session']
#    files = os.listdir(os.path.join(app.config['UPLOAD_FOLDER'], session_id))
#    print('user:', user_id)
#    return render_template('index.html', files=files, classifiers=ast.literal_eval(config['classifiers']))

def preprocess_sequences(sequences):
    # Preprocess the sequences if needed
    # For enzyme sequences, you can apply any specific preprocessing steps here.
    return sequences

def load_trained_model_and_vectorizer():
    # Load the already trained model
    model_path = 'lr_tf_idf_multiclass_SMOTE.sav'
    model = joblib.load(model_path)

    # Load the vectorizer used during training
    vectorizer_path = 'vectorizer_bio.pkl'
    vectorizer = joblib.load(vectorizer_path)

    return model, vectorizer

@app.route('/ml_preprocessing', methods=['POST', 'GET'])
def ml_preprocessing():
    if request.method == 'POST':
        # Check if the post request has the file part
        if 'file' not in request.files:
            flash('No file part', 'error')
            return redirect(request.url)

        file = request.files['file']

        if file.filename == '':
            flash('No selected file', 'error')
            return redirect(request.url)

        if file and allowed_file(file.filename):
            # Save the uploaded file to the UPLOAD_FOLDER
            if not os.path.exists(app.config['UPLOAD_FOLDER']):
                os.makedirs(app.config['UPLOAD_FOLDER'])
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
            file.save(file_path)

            return render_template('ml_classification.html', file_path=file_path)

        else:
            flash('Invalid file type', 'error')

    return render_template('ml_processing.html')

@app.route('/ml_classification', methods=['POST'])
def upload_vectorizer():
    # Get the file_path from the form data
    file_path = request.form['file_path']

    # Check if the post request has the vectorizer file part
    if 'vectorizer' not in request.files:
        flash('No vectorizer file part', 'error')
        return redirect(request.url)

    vectorizer_file = request.files['vectorizer']

    if vectorizer_file.filename == '':
        flash('No selected vectorizer file', 'error')
        return redirect(request.url)

    if vectorizer_file and allowed_file(vectorizer_file.filename):
        # Save the uploaded vectorizer to the UPLOAD_FOLDER
        vectorizer_path = os.path.join(app.config['UPLOAD_FOLDER'], vectorizer_file.filename)
        vectorizer_file.save(vectorizer_path)

        # Load the vectorizer
        vectorizer = joblib.load(vectorizer_path)

        # Load trained model
        #model, _ = load_trained_model_and_vectorizer()

        # Read and preprocess the sequences
        #data = pd.read_csv(file_path)
        #sequences = data['Protein Sequence'].tolist()
        #preprocessed_sequences = preprocess_sequences(sequences)

        # Transform the sequences using the vectorizer
        #X_test = vectorizer.transform(preprocessed_sequences)

        # Get the predictions
        #predictions = model.predict(X_test)
        #print(predictions)

        # Map class labels to their respective names (if needed)
        #class_mapping = {
        #    0: 'ligases',
        #    1: 'lyases',
        #    2: 'hydrolases',
        #    3: 'isomerase',
        #    4: 'translocase',
        #    5: 'transferases',
        #    6: 'non enzyme',
        #    7: 'oxidoreductase'
        #}

        #predicted_labels = [class_mapping[label] for label in predictions]

        # Combine the sequences with the predictions
        #data['Predicted Label'] = predicted_labels

        # Set the file_uploaded variable to True to show the success message in the HTML
        file_uploaded = True

        return render_template('ml_classification.html', file_path=file_path, file_uploaded=file_uploaded)

    else:
        flash('Invalid vectorizer file type', 'error')

    return render_template('ml_preprocessing.html', file_path=file_path)



@app.route('/ml_classification', methods=['GET', 'POST'])
def ml_classification():
    # Get the file_path from the form data
    file_path = request.form.get('file_path')

    # Load the already trained model and vectorizer
    model_path = 'lr_tf_idf_multiclass_SMOTE.sav'
    vectorizer_path = 'vectorizer_bio.pkl'
    
    try:
        model = joblib.load(model_path)
        vectorizer = joblib.load(vectorizer_path)
    except Exception as e:
        return render_template('ml_classification.html', file_path=file_path, error=f'Error loading model or vectorizer: {str(e)}')

    # Read and preprocess the sequences
    data = pd.read_csv(file_path)
    sequences = data['Protein Sequence'].tolist()
    preprocessed_sequences = preprocess_sequences(sequences)

    # Transform the sequences using the vectorizer
    X_test = vectorizer.transform(preprocessed_sequences)

    # Get the predictions
    predictions = model.predict(X_test)

    # Map class labels to their respective names (if needed)
    class_mapping = {
        0: 'ligases',
        1: 'lyases',
        2: 'hydrolases',
        3: 'isomerase',
        4: 'translocase',
        5: 'transferases',
        6: 'non enzyme',
        7: 'oxidoreductase'
    }

    predicted_labels = [class_mapping[label] for label in predictions]
    

    # Combine the sequences with the predictions
    data['Predicted Label'] = predicted_labels

    return render_template('display_results.html', data=data.to_html(index=False))


if __name__ == "__main__":
    app.run(debug=True)
